clear_screen
print("<b>====== Exploit Verifier v5.0 ======</b>")
print("")

logIcons = {"INFO": "‚ÑπÔ∏è", "WARN": "‚ö†Ô∏è", "ERROR": "‚ùå", "OK": "‚úÖ"}
DEBUG_MODE = 0

log = function(level, message)
    emoji = logIcons[level]
    if not emoji then
        emoji = "üîπ"
    end if
    print(emoji + " [" + level + "] " + message)
end function

debug_log = function(message)
end function

trace_log = function(message)
end function

mem_log = function(message)
end function

integrity_log = function(message)
end function

trim_input = function(texto)
    if not texto then
        return ""
    end if
    inicio = 0
    fim = texto.len - 1
    while inicio < texto.len and (texto[inicio] == " " or texto[inicio] == char(9))
        inicio = inicio + 1
    end while
    while fim >= inicio and (texto[fim] == " " or texto[fim] == char(9))
        fim = fim - 1
    end while
    if fim < inicio then
        return ""
    end if
    return texto[inicio:fim+1]
end function

limpar_texto = function(valor)
    if not valor then
        return ""
    end if
    texto = ""
    for c in valor.values
        codigo = c.code
        if codigo < 32 and codigo != 9 then
            continue
        end if
        texto = texto + c
    end for
    return texto.trim
end function

normalizar_texto = function(valor)
    if not valor then
        return ""
    end if
    return limpar_texto(valor).lower
end function

extrair_primeiro_numero = function(texto)
    if not texto then
        return ""
    end if
    numero = ""
    for c in texto.values
        if c >= "0" and c <= "9" then
            numero = numero + c
        else
            if numero.len > 0 then
                break
            end if
        end if
    end for
    return numero
end function

// CORRECAO PROBLEMA #1: Extrair valores SEM duplicacao - USAR LIST EM VEZ DE MAP
extrair_valores_vulneraveis = function(texto, addr_context)
    trace_log("=== INICIO extrair_valores_vulneraveis para " + addr_context + " ===")
    valores = []
    chaves_vistas = []  // MUDANCA: usar lista em vez de map
    linhas = texto.split(char(10))

    contador_unsafe = 0
    contador_html = 0
    contador_duplicados = 0

    for linha in linhas
        linha_limpa = limpar_texto(linha)
        valor_encontrado_nesta_linha = 0  // Flag para evitar processar mesma linha 2x

        // METODO 1: Unsafe check
        if linha_limpa.indexOf("Unsafe check:") != null then
            inicio = linha_limpa.indexOf(":") + 1
            fim = linha_limpa.indexOf(".")
            if fim == null then
                fim = linha_limpa.len
            end if
            if fim > inicio then
                valor_bruto = limpar_texto(linha_limpa[inicio:fim])
                partes = valor_bruto.split(" ")
                if partes.len > 0 then
                    valor = limpar_texto(partes[partes.len - 1])
                    chave = normalizar_texto(valor)

                    if chave.len > 0 then
                        // MUDANCA: usar indexOf em vez de hasIndex
                        if chaves_vistas.indexOf(chave) == null then
                            valores.push(valor)
                            chaves_vistas.push(chave)
                            contador_unsafe = contador_unsafe + 1
                            valor_encontrado_nesta_linha = 1  // MARCAR FLAG
                            trace_log("  [UNSAFE] Valor novo: " + valor + " [chave:" + chave + "]")
                        else
                            contador_duplicados = contador_duplicados + 1
                            trace_log("  [UNSAFE] Duplicado ignorado: " + valor + " [chave:" + chave + "]")
                        end if
                    end if
                end if
            end if
        end if

        // METODO 2: HTML tags - APENAS se NAO encontrou valor nesta linha ainda
        if valor_encontrado_nesta_linha == 0 and linha_limpa.indexOf("<b>") != null then
            inicio = linha_limpa.indexOf("<b>") + 3
            fim = linha_limpa.indexOf("</b>")
            if fim > inicio then
                valor = limpar_texto(linha_limpa[inicio:fim])
                chave = normalizar_texto(valor)

                if chave.len > 0 then
                    // MUDANCA: usar indexOf em vez de hasIndex
                    if chaves_vistas.indexOf(chave) == null then
                        valores.push(valor)
                        chaves_vistas.push(chave)
                        contador_html = contador_html + 1
                        trace_log("  [HTML] Valor novo: " + valor + " [chave:" + chave + "]")
                    else
                        contador_duplicados = contador_duplicados + 1
                        trace_log("  [HTML] Duplicado ignorado: " + valor + " [chave:" + chave + "]")
                    end if
                end if
            end if
        end if
    end for

    mem_log("Extracao finalizada - Total: " + valores.len + " unicos (Unsafe:" + contador_unsafe + ", HTML:" + contador_html + ", Duplicados:" + contador_duplicados + ")")
    trace_log("=== FIM extrair_valores_vulneraveis - Retornando " + valores.len + " valores ===")

    return valores
end function

// CORRECAO PROBLEMA #2: Formatar sem duplicacao adicional - USAR LIST EM VEZ DE MAP
formatar_valores_vulneraveis = function(lista)
    trace_log("=== INICIO formatar_valores_vulneraveis ===")
    if not lista then
        lista = []
    end if

    trace_log("Input: " + lista.len + " itens -> [" + lista.join(", ") + "]")

    if lista.len == 0 then
        trace_log("Lista vazia, retornando ???")
        return "???"
    end if

    // Ja deveria vir deduplicado, mas garantir
    valores_finais = []
    chaves_finais = []  // MUDANCA: usar lista em vez de map
    duplicados_removidos = 0

    for item in lista
        valor_limpo = limpar_texto(item)
        if valor_limpo.len == 0 then
            trace_log("  Item vazio ignorado")
            continue
        end if

        chave = normalizar_texto(valor_limpo)
        if chave.len == 0 then
            trace_log("  Chave vazia para valor: " + valor_limpo)
            continue
        end if

        // MUDANCA: usar indexOf em vez de hasIndex
        if chaves_finais.indexOf(chave) == null then
            valores_finais.push(valor_limpo)
            chaves_finais.push(chave)
            trace_log("  Mantido: " + valor_limpo + " [" + chave + "]")
        else
            duplicados_removidos = duplicados_removidos + 1
            trace_log("  Duplicado removido: " + valor_limpo + " [" + chave + "]")
        end if
    end for

    if valores_finais.len == 0 then
        trace_log("Todos os valores descartados, retornando ???")
        return "???"
    end if

    resultado = valores_finais.join(", ")
    mem_log("Formatacao concluida: " + lista.len + " input -> " + valores_finais.len + " output (" + duplicados_removidos + " duplicados removidos)")
    trace_log("Output final: [" + resultado + "]")
    trace_log("=== FIM formatar_valores_vulneraveis ===")

    return resultado
end function

// CORRECAO PROBLEMA #4 e #5: Adicionar problema sem duplicacao - USAR LIST EM VEZ DE MAP
adicionar_problema_unico = function(lista, cache, mensagem, tipo)
    mensagem_limpa = limpar_texto(mensagem)
    chave_problema = tipo + "::" + normalizar_texto(mensagem_limpa)

    trace_log("  >>> Tentando adicionar problema <<<")
    trace_log("    Tipo: " + tipo)
    trace_log("    Mensagem: " + mensagem_limpa)
    trace_log("    Chave: " + chave_problema)

    // Verificar duplicata via cache - MUDANCA: usar indexOf em vez de hasIndex
    if cache and cache.indexOf(chave_problema) != null then
        trace_log("    DUPLICADO detectado via cache, IGNORANDO")
        return
    end if

    // Criar novo problema
    novo = {}
    novo.tipo = "" + tipo
    novo.mensagem = "" + mensagem_limpa
    novo._chave = "" + chave_problema

    lista.push(novo)

    if cache then
        cache.push(chave_problema)  // MUDANCA: push em vez de atribuicao
    end if

    trace_log("    ADICIONADO - Total de problemas agora: " + lista.len)

    // Mostrar estado atual
    debug_atual = []
    for p in lista
        debug_atual.push(p.tipo + ":" + p.mensagem)
    end for
    trace_log("    Estado da lista: [" + debug_atual.join(" | ") + "]")
end function

obter_tutorial = function(tipo)
    passos = []
    if tipo == "active_user" then
        passos.push("1. Re√∫na um email do dom√≠nio alvo (Mail.txt, site corporativo ou WHOIS).")
        passos.push("2. Abra Mail.exe, clique em Templates e escolha 'Online user'.")
        passos.push("3. Preencha o campo To com o email coletado e mantenha o assunto padr√£o.")
        passos.push("4. Envie e aguarde alguns segundos at√© que um usu√°rio comum fa√ßa login.")
        passos.push("5. Rode este verificador novamente para confirmar que estado_usuario_ativo=1.")
    else if tipo == "guest_user" then
        passos.push("Este requisito √© automaticamente satisfeito ao obter qualquer tipo de shell/acesso.")
        passos.push("N√£o requer a√ß√£o adicional - prossiga com o exploit normalmente.")
    else if tipo == "root_user" then
        passos.push("1. Descubra o dom√≠nio/nome da empresa do alvo (scanrouter, navegador ou arquivos p√∫blicos).")
        passos.push("2. No Mail.exe selecione o template 'Admin online'.")
        passos.push("3. Informe um endere√ßo do dom√≠nio correto e personalize o campo Company se o template pedir.")
        passos.push("4. Envie o email; o NPC root far√° login por alguns minutos.")
        passos.push("5. Reexecute o script para validar que estado_root_ativo=1 antes de tentar o exploit.")
    else if tipo == "users_exact" then
        passos.push("Este requisito depende do n√∫mero de contas reais do alvo; escolha outro exploit/porta.")
    else if tipo == "ports_exact" then
        passos.push("A contagem de port forwarding vem do roteador do alvo; procure outra porta ou roteador.")
    else if tipo == "ports_configured" then
        passos.push("Requisito de port forwarding detectado. Atual: " + globals.estado_num_portas + " porta(s).")
    else if tipo == "path_exists" then
        passos.push("Este requisito verifica se um caminho existe no filesystem do alvo.")
        passos.push("Geralmente √© satisfeito automaticamente em sistemas padr√£o.")
    end if
    return passos
end function

// CORRECAO PROBLEMA #3: Copiar problemas profundamente
copiar_problemas = function(origem)
    trace_log("  === copiar_problemas: " + origem.len + " itens ===")
    destino = []
    if not origem then
        trace_log("    Origem null, retornando lista vazia")
        return destino
    end if

    for item in origem
        if not item then
            trace_log("    Item null encontrado, pulando")
            continue
        end if

        // Criar NOVO objeto, nao reutilizar referencia
        copia = {}
        copia.tipo = "" + item.tipo
        copia.mensagem = "" + item.mensagem
        if item._chave then
            copia._chave = "" + item._chave
        end if

        destino.push(copia)
        trace_log("    Copiado: " + copia.tipo + " - " + copia.mensagem)
    end for

    trace_log("  === copiar_problemas: retornando " + destino.len + " copias ===")
    return destino
end function

// CORRECAO PROBLEMA #3: Criar snapshot independente
criar_snapshot_analise = function(addr_original, valor_formatado, lista_problemas, contexto)
    mem_log(">>> CRIANDO SNAPSHOT para " + addr_original + " (contexto: " + contexto + ") <<<")

    // Criar objeto NOVO com strings copiadas
    snapshot = {}
    snapshot.addr = "" + addr_original
    snapshot.valor = "" + valor_formatado
    snapshot.problemas = copiar_problemas(lista_problemas)

    mem_log("  Addr: " + snapshot.addr)
    mem_log("  Valor: " + snapshot.valor)
    mem_log("  Problemas: " + snapshot.problemas.len)

    // Verificar integridade imediata
    if snapshot.addr != addr_original then
        log("ERROR", "CORRUPCAO IMEDIATA: addr esperado=" + addr_original + ", obtido=" + snapshot.addr)
    end if

    if snapshot.valor != valor_formatado then
        log("ERROR", "CORRUPCAO IMEDIATA: valor esperado=" + valor_formatado + ", obtido=" + snapshot.valor)
    end if

    mem_log("<<< SNAPSHOT CRIADO com sucesso >>>")
    return snapshot
end function

shell = get_shell
if not shell then
    log("ERROR", "Shell atual nao encontrado.")
    exit("")
end if

pc = shell.host_computer
if not pc then
    log("ERROR", "Computador hospedeiro nao encontrado.")
    exit("")
end if

ip = trim_input(user_input("Digite o IP alvo: "))
if ip.len == 0 then
    log("WARN", "Nenhum IP informado. Encerrando.")
    exit("")
end if

nmapPath = "/bin/nmap"
nmapFile = pc.File(nmapPath)
if nmapFile then
    log("INFO", "Executando nmap em " + ip + "...")
    shell.launch(nmapPath, ip)
    log("INFO", "Selecione uma das portas exibidas pelo nmap.")
else
    log("WARN", "Nmap nao encontrado em " + nmapPath + ". Pule esta etapa manualmente.")
end if

porta_input = trim_input(user_input("Digite a porta alvo: "))
if porta_input.len == 0 then
    log("WARN", "Nenhuma porta informada. Encerrando.")
    exit("")
end if

porta = porta_input.to_int
if porta <= 0 then
    log("ERROR", "Porta invalida: " + porta_input)
    exit("")
end if

// Carregar metaxploit
meta = include_lib("/lib/metaxploit.so")
if not meta then
    meta = include_lib(current_path + "/metaxploit.so")
end if
if not meta then
    log("ERROR", "metaxploit.so nao encontrado em /lib ou no diret√≥rio atual.")
    exit("")
end if

// Conectar
log("INFO", "Conectando a " + ip + ":" + porta + "...")
sessao = meta.net_use(ip, porta)
if not sessao then
    log("ERROR", "Falha na conexao com o alvo. Verifique IP e porta.")
    exit("")
end if

lib = sessao.dump_lib
print("[+] Biblioteca: " + lib.lib_name + " v" + lib.version)
print("")

// COLETAR ESTADO ATUAL DO ALVO
print("="*50)
print("  ESTADO ATUAL DO ALVO")
print("="*50)
globals.estado_usuario_ativo = sessao.is_any_active_user
globals.estado_root_ativo = sessao.is_root_active_user
globals.estado_num_usuarios = sessao.get_num_users
globals.estado_num_portas = sessao.get_num_portforward

print("[+] Usuario ativo........: " + globals.estado_usuario_ativo + " (1=sim, 0=nao)")
print("[+] Root ativo...........: " + globals.estado_root_ativo + " (1=sim, 0=nao)")
print("[+] Usuarios registrados.: " + globals.estado_num_usuarios)
print("[+] Portas redirecionadas: " + globals.estado_num_portas)
print("")

// ESCANEAR VULNERABILIDADES
print("="*50)
print("  ANALISE DE VULNERABILIDADES")
print("="*50)
enderecos_brutos = meta.scan(lib)
debug_log("Scan bruto retornou " + enderecos_brutos.len + " enderecos")

if enderecos_brutos.len == 0 then
    log("WARN", "Nenhuma vulnerabilidade encontrada nesta porta.")
    exit("")
end if

// DEDUPLICAR ENDERECOS - MUDANCA: usar lista em vez de map
enderecos = []
enderecos_vistos = []  // MUDANCA: lista em vez de map
duplicados_addr = 0

for addr_candidato in enderecos_brutos
    chave_addr = normalizar_texto(addr_candidato)
    // MUDANCA: usar indexOf em vez de hasIndex
    if enderecos_vistos.indexOf(chave_addr) == null then
        enderecos.push(addr_candidato)
        enderecos_vistos.push(chave_addr)  // MUDANCA: push em vez de atribuicao
        trace_log("Endereco unico #" + enderecos.len + ": " + addr_candidato + " [" + chave_addr + "]")
    else
        duplicados_addr = duplicados_addr + 1
        trace_log("Endereco DUPLICADO ignorado: " + addr_candidato)
    end if
end for

mem_log("Deduplicacao de enderecos: " + enderecos_brutos.len + " brutos -> " + enderecos.len + " unicos (" + duplicados_addr + " duplicados)")
print("[+] Encontradas " + enderecos.len + " vulnerabilidades unicas")
print("")

// ANALISAR CADA VULNERABILIDADE
analises = {}
ordem_analises = []

// CORRECAO ULTRA-CRITICA: converter loop principal para WHILE (for...in quebrado!)
// V5.0: Usar MAP em vez de primitivo (workaround closure bug #467)
num_enderecos = enderecos.len
mem_log("Iniciando analise de " + num_enderecos + " vulnerabilidades com WHILE loop")

loop_analise = {"idx": 0}
while loop_analise.idx < num_enderecos
    addr = enderecos[loop_analise.idx]
    loop_analise.idx = loop_analise.idx + 1

    print("="*50)
    log("INFO", "Analisando vulnerabilidade " + loop_analise.idx + "/" + num_enderecos)
    print("="*50)

    addr_limpo = limpar_texto(addr.trim)
    if addr_limpo.len == 0 then
        log("WARN", "Endereco vazio, pulando")
        continue
    end if

    chave_addr = normalizar_texto(addr_limpo)
    if chave_addr.len == 0 then
        chave_addr = addr_limpo.lower
    end if

    mem_log("Processando: addr_limpo='" + addr_limpo + "', chave='" + chave_addr + "'")

    // Verificar se ja foi analisado
    if analises.hasIndex(chave_addr) then
        log("WARN", "Chave " + chave_addr + " ja analisada, pulando")
        continue
    end if

    // SNAPSHOT PRE-ANALISE
    mem_log(">>> PRE-ANALISE SNAPSHOT <<<")
    mem_log("  Enderecos processados ate agora: " + ordem_analises.len)
    mem_log("  Analises no map: " + analises.indexes.len)

    // Executar scan_address
    info = meta.scan_address(lib, addr_limpo)
    debug_log("scan_address retornou " + info.len + " caracteres")

    // Mostrar output completo
    print("")
    print("==== SCAN OUTPUT PARA " + addr_limpo + " ====")
    print(info)
    print("="*60)
    print("")

    // Extrair valores vulneraveis
    valores_encontrados = extrair_valores_vulneraveis(info, addr_limpo)

    if valores_encontrados.len == 0 then
        log("WARN", "Nenhum valor vulneravel detectado para " + addr_limpo)
        valores_encontrados.push("???")
    end if

    mem_log("Valores extraidos: " + valores_encontrados.len + " -> [" + valores_encontrados.join(", ") + "]")

    // ANALISAR REQUISITOS
    problemas = []
    problemas_cache = []  // MUDANCA: lista em vez de map
    problemas_detectados = []
    paths_detectados = []  // MUDANCA: lista em vez de map para paths tambem

    linhas_info = info.split(char(10))

    for linha_raw in linhas_info
        linha_atual = limpar_texto(linha_raw)
        if linha_atual.len == 0 then
            continue
        end if

        // Verificar cada tipo de requisito
        if linha_atual.indexOf("Checking an active user") != null then
            trace_log("Requisito: active user detectado")
            if globals.estado_usuario_ativo == 0 then
                adicionar_problema_unico(problemas, problemas_cache, "Precisa usuario ativo (atual: 0)", "active_user")
                problemas_detectados.push("active_user")
            end if
        end if

        if linha_atual.indexOf("Checking guest active user") != null then
            trace_log("Requisito: guest user (informativo)")
        end if

        if linha_atual.indexOf("Checking root active user") != null then
            trace_log("Requisito: root active user detectado")
            if globals.estado_root_ativo == 0 then
                adicionar_problema_unico(problemas, problemas_cache, "Precisa root ativo (atual: 0)", "root_user")
                problemas_detectados.push("root_user")
            end if
        end if

        idx_users = linha_atual.indexOf("registered users equal to")
        if idx_users != null then
            resto_users = linha_atual[idx_users:]
            num_req = extrair_primeiro_numero(resto_users)
            if num_req.len > 0 then
                num_necessario = num_req.to_int
                trace_log("Requisito: users exact = " + num_necessario + " (atual: " + globals.estado_num_usuarios + ")")
                if globals.estado_num_usuarios != num_necessario then
                    mensagem = "Precisa " + num_necessario + " usuarios (atual: " + globals.estado_num_usuarios + ")"
                    adicionar_problema_unico(problemas, problemas_cache, mensagem, "users_exact")
                    problemas_detectados.push("users_exact:" + num_necessario)
                end if
            end if
        end if

        idx_ports = linha_atual.indexOf("forwarded ports equal to")
        if idx_ports != null then
            resto_ports = linha_atual[idx_ports:]
            num_req_ports = extrair_primeiro_numero(resto_ports)
            if num_req_ports.len > 0 then
                num_necessario = num_req_ports.to_int
                trace_log("Requisito: ports exact = " + num_necessario + " (atual: " + globals.estado_num_portas + ")")
                if globals.estado_num_portas != num_necessario then
                    mensagem = "Precisa " + num_necessario + " portas (atual: " + globals.estado_num_portas + ")"
                    adicionar_problema_unico(problemas, problemas_cache, mensagem, "ports_exact")
                    problemas_detectados.push("ports_exact:" + num_necessario)
                end if
            end if
        end if

        if linha_atual.indexOf("port forwarding configured") != null then
            num_configurado = extrair_primeiro_numero(linha_atual)
            if num_configurado.len > 0 then
                num_necessario = num_configurado.to_int
                trace_log("Requisito: ports configured = " + num_necessario)
                if globals.estado_num_portas != num_necessario then
                    mensagem = "Precisa " + num_necessario + " portas configuradas (atual: " + globals.estado_num_portas + ")"
                    adicionar_problema_unico(problemas, problemas_cache, mensagem, "ports_configured")
                    problemas_detectados.push("ports_configured:" + num_necessario)
                end if
            end if
        end if

        if linha_atual.indexOf("Checking path ") != null and linha_atual.indexOf(" exists") != null then
            idx_inicio = linha_atual.indexOf("Checking path ") + 14
            idx_exists = linha_atual.indexOf(" exists")
            if idx_exists > idx_inicio then
                caminho = limpar_texto(linha_atual[idx_inicio:idx_exists])
                caminho_chave = normalizar_texto(caminho)
                trace_log("Requisito: path exists = " + caminho)

                // MUDANCA: usar indexOf em vez de hasIndex
                if caminho_chave.len > 0 and paths_detectados.indexOf(caminho_chave) == null then
                    paths_detectados.push(caminho_chave)  // MUDANCA: push em vez de atribuicao
                    mensagem = "Requisito: caminho '" + caminho + "' deve existir"
                    adicionar_problema_unico(problemas, problemas_cache, mensagem, "path_exists")
                    problemas_detectados.push("path:" + caminho_chave)
                end if
            end if
        end if
    end for

    mem_log("Problemas detectados: " + problemas_detectados.join(", "))
    mem_log("Total de problemas na lista: " + problemas.len)

    // Mostrar problemas
    if problemas.len > 0 then
        debug_log("Lista de problemas antes de salvar:")
        for p in problemas
            debug_log("  - " + p.tipo + ": " + p.mensagem)
        end for
    else
        debug_log("Nenhum problema detectado - todos os requisitos atendidos")
    end if

    // FORMATAR VALORES
    valores_formatados = formatar_valores_vulneraveis(valores_encontrados)

    // CRIAR SNAPSHOT
    snapshot = criar_snapshot_analise(addr_limpo, valores_formatados, problemas, "pos-analise")

    // VALIDAR SNAPSHOT
    integrity_log("Validando snapshot antes de salvar no map")
    if snapshot.addr != addr_limpo then
        log("ERROR", "SNAPSHOT CORROMPIDO: addr esperado=" + addr_limpo + ", obtido=" + snapshot.addr)
    else
        integrity_log("Snapshot.addr: OK (" + snapshot.addr + ")")
    end if

    if snapshot.valor != valores_formatados then
        log("ERROR", "SNAPSHOT CORROMPIDO: valor esperado=" + valores_formatados + ", obtido=" + snapshot.valor)
    else
        // REMOVIDO: linha que causava crash com substring
        integrity_log("Snapshot.valor: OK (len=" + snapshot.valor.len + ")")
    end if

    // SALVAR NO MAP
    mem_log("Salvando snapshot no map com chave: " + chave_addr)
    analises[chave_addr] = snapshot

    // ADICIONAR NA ORDEM
    if ordem_analises.indexOf(chave_addr) == null then
        ordem_analises.push(chave_addr)
        mem_log("Chave adicionada na ordem de saida: " + chave_addr + " (posicao #" + ordem_analises.len + ")")
    end if

    // VERIFICACAO IMEDIATA POS-SAVE
    integrity_log("=== VERIFICACAO POS-SAVE ===")
    verificacao = analises[chave_addr]
    if not verificacao then
        log("ERROR", "MAPA CORROMPIDO: chave " + chave_addr + " retornou null apos salvar!")
    else
        if verificacao.addr != addr_limpo then
            log("ERROR", "MAPA CORROMPIDO: addr salvo=" + addr_limpo + ", recuperado=" + verificacao.addr)
        else
            integrity_log("Integridade OK: addr recuperado = " + verificacao.addr)
        end if

        if verificacao.problemas.len != problemas.len then
            log("ERROR", "PROBLEMAS CORROMPIDOS: salvo=" + problemas.len + ", recuperado=" + verificacao.problemas.len)
        else
            integrity_log("Integridade OK: " + verificacao.problemas.len + " problemas mantidos")
        end if
    end if

    // DEBUG: confirmar que chegamos aqui

    // MOSTRAR ESTADO COMPLETO DO MAP - USAR PRINT DIRETO PARA FORCAR SAIDA
    num_chaves_ordem = ordem_analises.len

    // WORKAROUND ULTRA-CRITICO: usar WHILE para copiar lista (for...in esta quebrado!)
    // V5.0: Usar MAP em vez de primitivo (workaround closure bug #467)
    chaves_para_verificar = []
    loop_copy = {"idx": 0}
    while loop_copy.idx < num_chaves_ordem
        chaves_para_verificar.push(ordem_analises[loop_copy.idx])
        loop_copy.idx = loop_copy.idx + 1
    end while

    loop_check = {"idx": 0}
    while loop_check.idx < chaves_para_verificar.len
        chave_check = chaves_para_verificar[loop_check.idx]
        entrada_check = analises[chave_check]
        if entrada_check then
        else
            log("ERROR", "Entrada NULL na posicao #" + loop_check.idx + " para chave " + chave_check)
        end if
        loop_check.idx = loop_check.idx + 1
    end while

    print("")
end while

mem_log("Loop principal finalizado - Analisadas " + loop_analise.idx + " vulnerabilidades")

// VERIFICACAO FINAL DE INTEGRIDADE
integrity_log("=== VERIFICACAO FINAL DE INTEGRIDADE ===")
integrity_log("Enderecos analisados: " + enderecos.len)
integrity_log("Chaves na ordem: " + ordem_analises.len)
integrity_log("Chaves no map: " + analises.indexes.len)

if ordem_analises.len != analises.indexes.len then
    log("ERROR", "INCONSISTENCIA: ordem tem " + ordem_analises.len + " mas map tem " + analises.indexes.len)
end if

// MOSTRAR RESULTADOS
print("")
print("="*50)
print("  RESULTADO DAS VULNERABILIDADES")
print("="*50)
print("")

if ordem_analises.len == 0 then
    log("WARN", "Nenhuma vulnerabilidade analisada")
else
    ok = 0
    pendente = 0

    // WORKAROUND ULTRA-CRITICO: copiar lista com WHILE (for...in quebrado!)
    // V5.0: Usar MAP em vez de primitivo (workaround closure bug #467)
    num_total_chaves = ordem_analises.len

    chaves_para_exibir = []
    loop_copy_exibir = {"idx": 0}
    while loop_copy_exibir.idx < num_total_chaves
        chaves_para_exibir.push(ordem_analises[loop_copy_exibir.idx])
        loop_copy_exibir.idx = loop_copy_exibir.idx + 1
    end while

    loop_exibir = {"idx": 0}
    while loop_exibir.idx < chaves_para_exibir.len
        chave = chaves_para_exibir[loop_exibir.idx]
        trace_log("Processando resultado #" + loop_exibir.idx + " com chave: " + chave)

        // Maps ainda precisam usar hasIndex para checagem de existencia
        if not analises.hasIndex(chave) then
            log("ERROR", "Chave " + chave + " ausente no map!")
            loop_exibir.idx = loop_exibir.idx + 1
            continue
        end if

        e = analises[chave]
        if not e then
            log("ERROR", "Entrada NULL para chave " + chave)
            loop_exibir.idx = loop_exibir.idx + 1
            continue
        end if

        // CORRECAO PROBLEMA #9: Armazenar tamanho ANTES de usar
        num_problemas = 0
        if e.problemas then
            num_problemas = e.problemas.len
        end if

        mem_log("Resultado #" + loop_exibir.idx + ": addr=" + e.addr + ", valor_len=" + e.valor.len + ", problemas=" + num_problemas)
        integrity_log("PRE-PRINT: e.problemas existe? " + (e.problemas != null) + ", len=" + num_problemas)

        print("")
        if num_problemas == 0 then
            status = "OK"
            ok = ok + 1
        else
            status = "PENDENTE"
            pendente = pendente + 1
        end if

        print("[" + status + "] " + e.addr)
        print("    Valor vulneravel.: " + e.valor)

        if num_problemas == 0 then
            print("    Requisitos.......: Todos atendidos")
        else
            print("    Requisitos.......: " + num_problemas + " pendente(s)")
            if e.problemas then
                for problema in e.problemas
                    print("      - " + problema.mensagem)
                    passos = obter_tutorial(problema.tipo)
                    if passos.len > 0 then
                        print("        Tutorial:")
                        for passo in passos
                            print("          " + passo)
                        end for
                    end if
                end for
            else
                log("ERROR", "e.problemas e NULL mas num_problemas=" + num_problemas)
            end if
        end if

        loop_exibir.idx = loop_exibir.idx + 1
    end while

    mem_log("Loop de exibicao finalizado - Processados: " + loop_exibir.idx + " resultados")

    print("")
    print("Resumo: " + ok + " atendem todos os requisitos, " + pendente + " exigem preparacao adicional.")
    mem_log("RESUMO FINAL: ok=" + ok + ", pendente=" + pendente)
end if

// SUGESTOES
print("")
print("="*50)
print("  COMO RESOLVER")
print("="*50)

if globals.estado_usuario_ativo == 0 then
    print("[!] Para ativar usuario: envie email com template 'Online user'")
end if

if globals.estado_root_ativo == 0 then
    print("[!] Para ativar root: envie email com template 'Admin online'")
end if

print("[!] Usuarios registrados e portas NAO podem ser alterados")
print("[!] Se nenhum exploit funciona, tente outra porta ou roteador")
print("")
print("Nota: Este script atua apenas como VERIFICADOR. Nenhum exploit e executado automaticamente.")
mem_log("=== EXECUCAO CONCLUIDA COM SUCESSO ===")
